var encode_1 = encode;

var MSB = 0x80;
var REST = 0x7F;
var MSBALL = ~REST;
var INT = Math.pow(2, 31);

function encode(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;

  while(num >= INT) {
    out[offset++] = (num & 0xFF) | MSB;
    num /= 128;
  }
  while(num & MSBALL) {
    out[offset++] = (num & 0xFF) | MSB;
    num >>>= 7;
  }
  out[offset] = num | 0;
  
  encode.bytes = offset - oldOffset + 1;
  
  return out
}

var decode = read;

var MSB$1 = 0x80;
var REST$1 = 0x7F;

function read(buf, offset) {
  var res    = 0
    , offset = offset || 0
    , shift  = 0
    , counter = offset
    , b
    , l = buf.length;

  do {
    if (counter >= l) {
      read.bytes = 0;
      throw new RangeError('Could not decode varint')
    }
    b = buf[counter++];
    res += shift < 28
      ? (b & REST$1) << shift
      : (b & REST$1) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$1)

  read.bytes = counter - offset;

  return res
}

var N1 = Math.pow(2,  7);
var N2 = Math.pow(2, 14);
var N3 = Math.pow(2, 21);
var N4 = Math.pow(2, 28);
var N5 = Math.pow(2, 35);
var N6 = Math.pow(2, 42);
var N7 = Math.pow(2, 49);
var N8 = Math.pow(2, 56);
var N9 = Math.pow(2, 63);

var length = function (value) {
  return (
    value < N1 ? 1
  : value < N2 ? 2
  : value < N3 ? 3
  : value < N4 ? 4
  : value < N5 ? 5
  : value < N6 ? 6
  : value < N7 ? 7
  : value < N8 ? 8
  : value < N9 ? 9
  :              10
  )
};

var E__Source_zerotoheroes_forks_hearthstoneDeckstrings_node_modules_varint = {
    encode: encode_1
  , decode: decode
  , encodingLength: length
};

/** @internal */
function atob_binary(encoded) {
    return atob(encoded);
}
/** @internal */
function btoa_binary(decoded) {
    return btoa(decoded);
}

/** @internal */
class Iterator {
    constructor() {
        this.index = 0;
    }
    next(repeat = 1) {
        this.index += repeat;
    }
}
/** @internal */
class BufferWriter extends Iterator {
    constructor() {
        super();
        this.buffer = [];
    }
    null() {
        this.buffer[this.index] = 0;
        this.next();
    }
    varint(value) {
        E__Source_zerotoheroes_forks_hearthstoneDeckstrings_node_modules_varint.encode(value, this.buffer, this.index);
        this.next(E__Source_zerotoheroes_forks_hearthstoneDeckstrings_node_modules_varint.encode.bytes);
    }
    byte(value) {
        this.buffer[this.index] = value;
        this.next();
    }
    toString() {
        const binary = String.fromCharCode(...this.buffer);
        return btoa_binary(binary);
    }
}
/** @internal */
class BufferReader extends Iterator {
    constructor(string) {
        super();
        const binary = atob_binary(string);
        const buffer = new Uint8Array(binary.length);
        for (let i = 0; i < binary.length; i++) {
            buffer[i] = binary.charCodeAt(i);
        }
        this.buffer = buffer;
    }
    nextByte() {
        const value = this.buffer[this.index];
        this.next();
        return value;
    }
    nextVarint() {
        const value = E__Source_zerotoheroes_forks_hearthstoneDeckstrings_node_modules_varint.decode(this.buffer, this.index);
        this.next(E__Source_zerotoheroes_forks_hearthstoneDeckstrings_node_modules_varint.decode.bytes);
        return value;
    }
}

const DECKSTRING_VERSION = 1;
const FormatType = {
    FT_WILD: 1,
    FT_STANDARD: 2,
    FT_CLASSIC: 3,
    FT_TWIST: 4,
};

function sorted_cards(cards) {
    return cards.sort((a, b) => (a[0] < b[0] ? -1 : a[0] > b[0] ? 1 : 0));
}
function trisort_cards(cards) {
    const single = [], double = [], n = [];
    for (const tuple of cards) {
        let list;
        const [card, count] = tuple;
        verifyDbfId(card, "card");
        if (count === 0) {
            continue;
        }
        if (count === 1) {
            list = single;
        }
        else if (count === 2) {
            list = double;
        }
        else if (isPositiveNaturalNumber(count)) {
            list = n;
        }
        else {
            throw new Error(`Invalid count ${count} (expected positive natural number)`);
        }
        list.push(tuple);
    }
    return [single, double, n];
}
function verifyDbfId(id, name) {
    name = name ? name : "dbf id";
    if (!isPositiveNaturalNumber(id)) {
        throw new Error(`Invalid ${name} ${id} (expected valid dbf id)`);
    }
}
function isPositiveNaturalNumber(n) {
    if (typeof n !== "number" || !isFinite(n)) {
        return false;
    }
    if (Math.floor(n) !== n) {
        return false;
    }
    return n > 0;
}

// See ShareableDeck#SerializeToVersion_1
const encode$1 = (deck) => {
    if (typeof deck !== "object" ||
        (deck.format !== FormatType.FT_WILD &&
            deck.format !== FormatType.FT_STANDARD &&
            deck.format !== FormatType.FT_TWIST &&
            deck.format !== FormatType.FT_CLASSIC) ||
        !Array.isArray(deck.heroes) ||
        !Array.isArray(deck.cards)) {
        throw new Error("Invalid deck definition");
    }
    const writer = new BufferWriter();
    const format = deck.format;
    const heroes = deck.heroes.slice().sort();
    const cards = sorted_cards(deck.cards.slice());
    writer.null();
    writer.varint(DECKSTRING_VERSION);
    writer.varint(format);
    writer.varint(heroes.length);
    for (let hero of heroes) {
        verifyDbfId(hero, "hero");
        writer.varint(hero);
    }
    for (let list of trisort_cards(cards)) {
        writer.varint(list.length);
        for (let tuple of list) {
            const [card, count] = tuple;
            writer.varint(card);
            if (count !== 1 && count !== 2) {
                writer.varint(count);
            }
        }
    }
    const hasSideboard = !!deck.sideboards && deck.sideboards.length > 0 ? 1 : 0;
    writer.byte(hasSideboard);
    if (hasSideboard && deck.sideboards != undefined) {
        serialize_WriteSideBoardCards(writer, deck);
    }
    return writer.toString();
};
// ShareableDeck#Serialize_WriteSideBoardCards()
const serialize_WriteSideBoardCards = (writer, deck) => {
    // For now, a single sideboard is supported
    // TODO: Support multiple sideboards
    // const sideboard = deck.sideboards[i];
    const sideboardCards = deck
        .sideboards.flatMap(s => buildSideBoardCardData(s))
        .sort((a, b) => (a.dbfId < b.dbfId ? -1 : a.dbfId > b.dbfId ? 1 : 0));
    const cards = sideboardCards.filter(c => c.quantity === 1);
    const cards2 = sideboardCards.filter(c => c.quantity === 2);
    const array = sideboardCards.filter(c => c.quantity > 2);
    serialize_WriteArrayOfSideBoardCards(writer, cards);
    serialize_WriteArrayOfSideBoardCards(writer, cards2);
    writer.varint(array.length);
    for (const card of array) {
        writer.varint(card.quantity);
        writer.varint(card.dbfId);
        writer.varint(card.linkedCardDbfId);
    }
};
const serialize_WriteArrayOfSideBoardCards = (writer, cards) => {
    writer.varint(cards.length);
    for (const card of cards) {
        writer.varint(card.dbfId);
        writer.varint(card.linkedCardDbfId);
    }
};
const buildSideBoardCardData = (sideboard) => {
    return sideboard.cards.map(c => {
        return {
            quantity: c[1],
            dbfId: c[0],
            linkedCardDbfId: sideboard.keyCardDbfId,
        };
    });
};

function decode$2(deckstring) {
    const reader = new BufferReader(deckstring);
    const nextByte = reader.nextByte();
    if (nextByte !== 0) {
        throw new Error("Invalid deckstring " + nextByte);
    }
    const version = reader.nextVarint();
    if (version !== DECKSTRING_VERSION) {
        throw new Error(`Unsupported deckstring version ${version}`);
    }
    const format = reader.nextVarint();
    if (format !== FormatType.FT_WILD &&
        format !== FormatType.FT_STANDARD &&
        format !== FormatType.FT_TWIST &&
        format !== FormatType.FT_CLASSIC) {
        throw new Error(`Unsupported format ${format} in deckstring`);
    }
    const heroes = new Array(reader.nextVarint());
    for (let i = 0; i < heroes.length; i++) {
        heroes[i] = reader.nextVarint();
    }
    heroes.sort();
    const cards = [];
    for (let i = 1; i <= 3; i++) {
        for (let j = 0, c = reader.nextVarint(); j < c; j++) {
            cards.push([
                reader.nextVarint(),
                i === 1 || i === 2 ? i : reader.nextVarint(),
            ]);
        }
    }
    sorted_cards(cards);
    let sideboards = undefined;
    const hasSideboard = reader.nextByte();
    if (hasSideboard === 1) {
        sideboards = [];
        for (let i = 1; i <= 3; i++) {
            // 1 = single cards, 2 = two copies, 3 = more than 2
            const numberOfEntries = reader.nextVarint();
            // The last ID is the sideboard's key card
            for (let j = 0; j < numberOfEntries; j++) {
                const cardId = reader.nextVarint();
                const numberOfCopies = i === 1 || i === 2 ? i : reader.nextVarint();
                const keyCardId = reader.nextVarint();
                let sideboard = sideboards.find(s => s.keyCardDbfId === keyCardId);
                if (!sideboard) {
                    sideboard = {
                        cards: [],
                        keyCardDbfId: keyCardId,
                    };
                    sideboards.push(sideboard);
                }
                sideboard.cards.push([cardId, numberOfCopies]);
            }
        }
        for (const sideboard of sideboards) {
            sideboard.cards = sorted_cards(sideboard.cards);
        }
    }
    return {
        cards,
        heroes,
        format,
        sideboards,
    };
}
function encodeMercs(deck) {
    const writer = new BufferWriter();
    writer.varint(8);
    writer.varint(deck.teamId);
    writer.varint(18);
    const teamNameArray = new TextEncoder().encode(deck.name);
    const bufferSize = teamNameArray.length;
    // const teamNameWriter = new BufferWriter();
    // for (let i = 0; i < bufferSize; i++) {
    // 	teamNameWriter.byte(teamNameArray[i]);
    // }
    writer.varint(bufferSize);
    for (let i = 0; i < bufferSize; i++) {
        writer.byte(teamNameArray[i]);
    }
    writer.varint(24);
    writer.varint(deck.type != null ? deck.type : 1);
    writer.varint(34);
    const teamWriter = new BufferWriter();
    writeTeamInfo(teamWriter, deck.mercenaries);
    const mercenaryListBlockSize = teamWriter.buffer.length;
    writer.varint(mercenaryListBlockSize);
    writeTeamInfo(writer, deck.mercenaries);
    writer.varint(40);
    writer.varint(10);
    return writer.toString();
}
function writeTeamInfo(teamWriter, team) {
    for (let i = 0; i < team.length; i++) {
        const merc = team[i];
        const mercWriter = new BufferWriter();
        writeMercInfo(mercWriter, merc);
        const mercenaryFieldSize = mercWriter.buffer.length;
        teamWriter.varint(10);
        teamWriter.varint(mercenaryFieldSize);
        writeMercInfo(teamWriter, merc);
    }
}
function writeMercInfo(mercWriter, merc) {
    mercWriter.varint(8);
    mercWriter.varint(merc.mercenaryId);
    mercWriter.varint(16);
    mercWriter.varint(merc.selectedEquipmentId);
    mercWriter.varint(24);
    mercWriter.varint(merc.selectedArtVariationId);
    mercWriter.varint(32);
    mercWriter.varint(merc.selectedArtVariationPremium);
}
function decodeMercs(deckstring) {
    const reader = new BufferReader(deckstring);
    const hasTeamId = reader.nextByte();
    if (hasTeamId !== 8) {
        throw new Error("Invalid deckstring " + hasTeamId);
    }
    const teamId = reader.nextVarint();
    const hasName = reader.nextByte();
    const teamNameSize = reader.nextByte();
    const teamNameArray = [];
    for (let i = 0; i < teamNameSize; i++) {
        teamNameArray.push(reader.nextByte());
    }
    const teamName = new TextDecoder().decode(new Uint8Array(teamNameArray));
    const hasType = reader.nextByte();
    const type = reader.nextByte();
    const hasMercenaryList = reader.nextByte();
    const mercenaryListBlockSize = reader.nextByte();
    const startListPosition = reader.index;
    const endListPosition = startListPosition + mercenaryListBlockSize;
    const team = [];
    // Read all the heroes
    while (true) {
        if (reader.index >= endListPosition) {
            break;
        }
        const mercenary = {};
        team.push(mercenary);
        const encodingType = reader.nextByte();
        if (encodingType !== 10) {
            throw new Error("non-length delimited encoding not supported yet " +
                encodingType);
        }
        const fieldsForMerc = reader.nextByte();
        const positionAtStart = reader.index;
        const positionAtEnd = positionAtStart + fieldsForMerc;
        // Read all fields
        while (true) {
            if (reader.index >= positionAtEnd) {
                break;
            }
            const nextInfo = reader.nextByte();
            switch (nextInfo) {
                case 8:
                    mercenary.mercenaryId = reader.nextByte();
                    continue;
                case 16:
                    mercenary.selectedEquipmentId = reader.nextByte();
                    continue;
                case 24:
                    mercenary.selectedArtVariationId = reader.nextByte();
                    continue;
                case 32:
                    mercenary.selectedArtVariationPremium = reader.nextByte();
                    continue;
                case 40:
                    mercenary.sharedTeamMercenaryXp = reader.nextByte();
                    continue;
                case 48:
                    mercenary.sharedTeamMercenaryIsFullyUpgraded = reader.nextByte();
                    continue;
                default:
                    // skip, no idea what these are
                    continue;
            }
        }
    }
    return {
        teamId: teamId,
        name: teamName,
        type: type,
        mercenaries: team,
    };
}

export { decode$2 as decode, encodeMercs, decodeMercs, FormatType, encode$1 as encode };
